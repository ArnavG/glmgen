
R Under development (unstable) (2014-04-10 r65396) -- "Unsuffered Consequences"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin13.1.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "glmgen"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('glmgen')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("glmgen-class")
> ### * glmgen-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glmgen-class
> ### Title: Class '"glmgen"'
> ### Aliases: glmgen-class coef,glmgen-method print,glmgen-method
> ###   show,glmgen-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("glmgen")
Class "glmgen" [package "glmgen"]

Slots:
                                                                            
Name:          y    lambda      beta    family    method         n         p
Class:   numeric   numeric    matrix character character   integer   integer
                                    
Name:          m       obj      call
Class:   integer   numeric      call

Known Subclasses: "trendfilter"
> 
> 
> 
> cleanEx()
> nameEx("summary.glmgen-class")
> ### * summary.glmgen-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.glmgen-class
> ### Title: Class '"summary.glmgen"'
> ### Aliases: summary.glmgen-class print,summary.glmgen-method
> ###   show,summary.glmgen-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("summary.glmgen")
Class "summary.glmgen" [package "glmgen"]

Slots:
              
Name:  summary
Class:  matrix
> 
> 
> 
> cleanEx()
> nameEx("trendfilter-class")
> ### * trendfilter-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trendfilter-class
> ### Title: Class '"trendfilter"'
> ### Aliases: trendfilter-class predict,trendfilter-method
> ###   summary,trendfilter-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("trendfilter")
Class "trendfilter" [package "glmgen"]

Slots:
                                                                            
Name:          y         x         k    lambda      beta    family    method
Class:   numeric   numeric   integer   numeric    matrix character character
                                                        
Name:          n         p         m       obj      call
Class:   integer   integer   integer   numeric      call

Extends: "glmgen"
> 
> 
> 
> cleanEx()
> nameEx("trendfilter")
> ### * trendfilter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: trendfilter
> ### Title: a
> ### Aliases: trendfilter
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (y, x, k, family = c("gaussian", "logistic", "poisson"),
+     lambda, nlambda = 100L, lambda.min.ratio = 1e-05, method = c("admm",
+         "prime_dual"), maxiter = 1e+06, objective = FALSE, control = list())
+ {
+     cl = match.call()
+     n = length(y)
+     nlam = as.integer(nlambda)
+     family = match.arg(family)
+     method = match.arg(method)
+     family_cd = match(family, c("gaussian", "logistic", "poisson")) -
+         1L
+     method_cd = match(method, c("admm", "prime_dual")) - 1L
+     if (k < 0 || k != floor(k))
+         stop("k must be a nonnegative integer.")
+     if (n < k + 2)
+         stop("y must have length >= k+2 for kth order trend filtering.")
+     if (maxiter <= 1L)
+         stop("maxiter must be greater than 1")
+     if (missing(lambda)) {
+         if (nlam <= 0L)
+             stop("nlambda must be a positive number.")
+         if (lambda.min.ratio < 0 | lambda.min.ratio > 1)
+             stop("lamba.min.ratio must be between 0 and 1.")
+     }
+     else {
+         if (length(lambda) == 0L)
+             stop("Must specify at least one lambda value.")
+         if (min(lambda) < 0L)
+             stop("All specified lambda values must be nonnegative.")
+         nlambda = length(lambda)
+     }
+     if (!is.list(control) | (is.null(names(control)) & length(control) !=
+         0L))
+         stop("control must be a named list")
+     control = lapply(control, function(v) ifelse(is.numeric(v),
+         as.double(v[[1]]), stop("Elements of control must be numeric.")))
+     if (is.null(x))
+         x = 1L:length(y)
+     if (missing(lambda)) {
+         lambda = rep(0, nlambda)
+         lambda_flag = FALSE
+     }
+     else lambda_flag = TRUE
+     z = .Call("tf_R", sY = as.double(y), sX = as.double(x), sN = length(y),
+         sK = as.integer(k), sFamily = as.integer(family_cd),
+         sMethod = as.integer(method_cd), sMaxIter = as.integer(maxiter),
+         sLamFlag = as.integer(lambda_flag), sObjFlag = as.integer(objective),
+         sLambda = as.double(lambda), sNlambda = as.integer(nlambda),
+         sLambdaMinRatio = as.double(lambda.min.ratio), sControl = control,
+         package = "glmgen")
+     if (is.null(z))
+         stop("Unspecified error in C code.")
+     if (!is.null(z$obj))
+         z$obj = z$obj[1:z$numiter]
+     else z$obj = NA_real_
+     colnames(z$beta) = as.character(round(z$lambda, 3))
+     out = new("trendfilter", y = y, x = x, k = as.integer(k),
+         lambda = z$lambda, beta = z$beta, family = family, method = method,
+         n = length(y), p = length(y), d = length(y) - as.integer(k) -
+             1L, obj = z$obj, call = cl)
+     out
+   }
function (y, x, k, family = c("gaussian", "logistic", "poisson"), 
    lambda, nlambda = 100L, lambda.min.ratio = 1e-05, method = c("admm", 
        "prime_dual"), maxiter = 1e+06, objective = FALSE, control = list()) 
{
    cl = match.call()
    n = length(y)
    nlam = as.integer(nlambda)
    family = match.arg(family)
    method = match.arg(method)
    family_cd = match(family, c("gaussian", "logistic", "poisson")) - 
        1L
    method_cd = match(method, c("admm", "prime_dual")) - 1L
    if (k < 0 || k != floor(k)) 
        stop("k must be a nonnegative integer.")
    if (n < k + 2) 
        stop("y must have length >= k+2 for kth order trend filtering.")
    if (maxiter <= 1L) 
        stop("maxiter must be greater than 1")
    if (missing(lambda)) {
        if (nlam <= 0L) 
            stop("nlambda must be a positive number.")
        if (lambda.min.ratio < 0 | lambda.min.ratio > 1) 
            stop("lamba.min.ratio must be between 0 and 1.")
    }
    else {
        if (length(lambda) == 0L) 
            stop("Must specify at least one lambda value.")
        if (min(lambda) < 0L) 
            stop("All specified lambda values must be nonnegative.")
        nlambda = length(lambda)
    }
    if (!is.list(control) | (is.null(names(control)) & length(control) != 
        0L)) 
        stop("control must be a named list")
    control = lapply(control, function(v) ifelse(is.numeric(v), 
        as.double(v[[1]]), stop("Elements of control must be numeric.")))
    if (is.null(x)) 
        x = 1L:length(y)
    if (missing(lambda)) {
        lambda = rep(0, nlambda)
        lambda_flag = FALSE
    }
    else lambda_flag = TRUE
    z = .Call("tf_R", sY = as.double(y), sX = as.double(x), sN = length(y), 
        sK = as.integer(k), sFamily = as.integer(family_cd), 
        sMethod = as.integer(method_cd), sMaxIter = as.integer(maxiter), 
        sLamFlag = as.integer(lambda_flag), sObjFlag = as.integer(objective), 
        sLambda = as.double(lambda), sNlambda = as.integer(nlambda), 
        sLambdaMinRatio = as.double(lambda.min.ratio), sControl = control, 
        package = "glmgen")
    if (is.null(z)) 
        stop("Unspecified error in C code.")
    if (!is.null(z$obj)) 
        z$obj = z$obj[1:z$numiter]
    else z$obj = NA_real_
    colnames(z$beta) = as.character(round(z$lambda, 3))
    out = new("trendfilter", y = y, x = x, k = as.integer(k), 
        lambda = z$lambda, beta = z$beta, family = family, method = method, 
        n = length(y), p = length(y), d = length(y) - as.integer(k) - 
            1L, obj = z$obj, call = cl)
    out
}
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.134 0.005 0.145 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
